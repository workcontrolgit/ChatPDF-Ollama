@using ChatPDF.Web.Services.Ingestion
@inject IJSRuntime JS
@inject IWebHostEnvironment Environment
@inject DataIngestor DataIngestor

<div class="document-upload">
    <label for="file-upload" class="btn-default upload-button">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="upload-icon">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
        </svg>
        Upload PDF
    </label>
    <InputFile id="file-upload" OnChange="@OnFileSelected" accept=".pdf" style="display: none;" />
    
    @if (isUploading)
    {
        <div class="upload-status uploading">
            <svg class="upload-spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Uploading...
        </div>
    }
    else if (!string.IsNullOrEmpty(uploadMessage))
    {
        <div class="upload-status @(uploadSuccess ? "success" : "error")">
            @uploadMessage
        </div>
    }
</div>

@code {
    private bool isUploading = false;
    private string uploadMessage = "";
    private bool uploadSuccess = false;

    [Parameter]
    public EventCallback OnDocumentUploaded { get; set; }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null)
            return;

        // Validate file type
        if (!file.Name.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase))
        {
            ShowMessage("Only PDF files are allowed.", false);
            return;
        }

        // Validate file size (limit to 10MB)
        if (file.Size > 10 * 1024 * 1024)
        {
            ShowMessage("File size must be less than 10MB.", false);
            return;
        }

        isUploading = true;
        uploadMessage = "";
        StateHasChanged();

        try
        {
            // Create the Data directory if it doesn't exist
            var dataPath = Path.Combine(Environment.WebRootPath, "Data");
            Directory.CreateDirectory(dataPath);

            // Generate unique filename to avoid conflicts
            var fileName = Path.GetFileNameWithoutExtension(file.Name);
            var extension = Path.GetExtension(file.Name);
            var uniqueFileName = $"{fileName}_{DateTime.Now:yyyyMMdd_HHmmss}{extension}";
            var filePath = Path.Combine(dataPath, uniqueFileName);

            // Save the file
            using (var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024))
            using (var fileStream = new FileStream(filePath, FileMode.Create))
            {
                await stream.CopyToAsync(fileStream);
            }

            // Ingest the new document
            var source = new PDFDirectorySource(dataPath);
            await DataIngestor.IngestDataAsync(source);

            ShowMessage($"'{file.Name}' uploaded and indexed successfully!", true);
            await OnDocumentUploaded.InvokeAsync();
        }
        catch (Exception ex)
        {
            ShowMessage($"Upload failed: {ex.Message}", false);
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
        }
    }

    private void ShowMessage(string message, bool success)
    {
        uploadMessage = message;
        uploadSuccess = success;
        StateHasChanged();

        // Clear message after 5 seconds
        _ = Task.Delay(5000).ContinueWith(_ =>
        {
            InvokeAsync(() =>
            {
                uploadMessage = "";
                StateHasChanged();
            });
        });
    }
}